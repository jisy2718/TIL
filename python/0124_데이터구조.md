[toc]

# 데이터 구조 (Data Structure)

+ **method** 

+ **function** : 앞에 .없는 것 이라고 생각

+ 자료 구조 (data structure) : 데이터를 저장하는 방식

  

## 1. 순서가 있는 데이터 구조

### [1] string (문자열)

+ ```dir('string'), dir(str)``` 으로 모든 method 확인

+ 문자열 표기

  + 문자열은 ``` ' ', ""``` 를 이용하여 표기

  + PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지

    

+ 문자열 조회 / 탐색 method

  | 명령어                                   | 설명                                                         | 예시 |
  | ---------------------------------------- | ------------------------------------------------------------ | ---- |
  | ```s.find(x ,start index, end index)```  | ```x```의 첫번째 위치를 반환 / 없으면 ```-1``` 반환          |      |
  | ```s.index(x, start index, end index)``` | ```x```의 첫번째 위치를 반환 / 없으면 ```ValueError```       |      |
  | ```s.startswith(x)```                    | ```x```로 문자열이 시작하면 ```True``` 아니면 ```False```반환 |      |
  | ```s.endswith(x)```                      | ```x```로 문자열이 끝나면 ```True``` 아니면 ```False```      |      |
  
  dictionary의 ```.get()```과 indexing 의 차이와 ```.find(), .index()``` 비슷
  
  ```python
  # x 의 모든 위치를 반환
  a = 'pppppppppp'
  length = len(a)
  i = 0 ; result = []
  while i < len(a):
      j = a.find('p', i)
      # 해당 문자가 없으면 break
      if j == -1:
          break
      # 해당 문자가 있다면 결과에 추가
      result.append(j)
      # j + 1 번 index 부터 보면 됨
      i = j + 1
  print(result)
  ```
  
  



+ 문자열 검증

  | 명령어            | 설명                                                         | 예시 |
  | ----------------- | ------------------------------------------------------------ | ---- |
  | ```s.isalpha()``` | (숫자가 아닌)  문자 여부 (유니코드상의 letter로 한국어 포함) :  ```'.'```은 False |      |
  | ```s.isspace()``` | 문자열이 공백으로 이루어져 있는가?  ```\n, \t```등 개행문자는 공백 |      |
  | ```s.isupper()``` |                                                              |      |
  | ```s.islower()``` |                                                              |      |
  | ```s.istitle()``` | 문자열이 타이틀 형식(띄어쓰기 첫 글자가 대문자)              |      |
  
  

+ 숫자 판별

  | 명령어              | 설명                        | 예시 |
  | ------------------- | --------------------------- | ---- |
  | ```s.isdecimal()``` | 문자열이 0~9까지 숫자?      |      |
  | ```s.isdigit()```   | 문자열이 숫자?              |      |
  | ```s.isnumeric()``` | 문자열을 수로 볼 수 있는가? |      |

  

+ 문자열 변경

  | 명령어                                      | 설명                                                         | 예시                |
  | ------------------------------------------- | ------------------------------------------------------------ | ------------------- |
  | ```s.replace(old, new, count)```            | old를 new로 count 번 변경시킴                                |                     |
  | ```s.strip([chars])``` ```rstrip, lstrip``` | 문자들을 좌우 / 우 /좌 에서 삭제<br /> 지정 안하면 공백(개행문자포함)을 제거 |                     |
  | **```s.split([chars])```**                  | 특정 문자를 기준으로 분리<br />지정안하면 여러 공백도 1개의 공백 |                     |
  | **```separator.join([iterable])```**        | separator을 사이에 끼워 iterable을 합침                      | ```''.join(iter)``` |
  | ```s.capitalize()```                        | 첫 글자를 대문자로 / 나머지는 소문자로                       |                     |
  | ```s.title(), s.upper(), s.lower()```       | title 경우 ' 다음도 대문자화                                 |                     |
  | ```s.swapcase()```                          | 대 소문자 변경                                               |                     |

  



### [2] list (리스트)

+ ```dir(list), dir([])``` 로 전체 method 확인 가능
+ 순서를 가지는 0개 이상의 객체를 참조하는 자료형

+ 값 추가 및 삭제

  | 명령어                   | 설명                                                 | 예시 |
  | ------------------------ | ---------------------------------------------------- | ---- |
  | ```L.insert(i, x)```     | index i에 ```x```를 삽입 / 기존 index i 는 i+1 됨    |      |
  | ```L.extend(iterable)``` | 리스트에 iterable(list, range, tuple, string)을 붙임 |      |
  | ```L.remove(x)```        | 첫 ```x```를 삭제 / 없으면 ```ValueError```          |      |
  | ```L.pop(i)```           | i 번째 값 삭제 후 반환 / 지정 안되면 마지막 값       |      |
  | ```L.clear()```          | 모든 항목 삭제                                       |      |
  |                          |                                                      |      |



+ 탐색 및 정렬

  | 명령어              | 설명                                                         | 예시 |
  | ------------------- | ------------------------------------------------------------ | ---- |
  | ```L.index(x)```    | ```x``` 값은 index 반환 / 없으면 ```ValueError```            |      |
  | ```L.count(x)```    | ```x``` 값의 개수를 반환                                     |      |
  | **```L.sort()```**  | 원본 리스트를 변형 후 ```None``` 반환                        |      |
  | **```sorted(L)```** | 원본을 변형하지 않고, 정렬된 리스트 반환                     |      |
  | ```L.reverse()```   | 원본을 변형 후 ```None``` 반환                               |      |
  | ```reversed(L)```   | 원본을 변형하지 않고, 뒤집은 ```list_reverseiterator```객체 반환 |      |

  





### [3] tuple (튜플)

+ ```dir(tuple)``` 로 전체 method 파악 가능

+ 순서를 가지는 0개 이상의 객체를 참조하는 자료형



+ 탐색 및 정렬

  | 명령어         | 설명 | 예시 |
  | -------------- | ---- | ---- |
  | ```.count()``` |      |      |
  | ```.index()``` |      |      |

  



## 2. 순서가 없는 데이터 구조



### [1] set (셋)

+ ```dir(set)``` 으로 모든 method 확인가능
+ 순서없이 0개 이상의 해시가능한 객체(immutable)를 참조하는 자료형
+ 담고있는 객체를 삽입 변경, 삭제 가능(mutable)



+ 추가 및 변경

  | 명령어                  | 설명                                                         | 예시 |
  | ----------------------- | ------------------------------------------------------------ | ---- |
  | ```s.update(*others)``` | iterable인 ```others```를 unpacking하고, 여러 값을 추가, 복수 인자 가능 |      |
  | ```s.remove('elem')```  | 제거, 없으면 ```KeyError```                                  |      |
  | ```s.discard('elem')``` | 제거, 없어도 에러 발생 안함                                  |      |
  | ```s.pop()```           | 임의의 원소를 제거하고, 반환                                 |      |





### [2] dictionary (딕셔너리)

+ ```dir(dict)```로 모든 method 확인

+ 변경 가능(mutable), 순서가 없고(unordered), 순회 가능함(iterable)



+ 조회 

  | 명령어                           | 설명                                                         | 예시 |
  | -------------------------------- | ------------------------------------------------------------ | ---- |
  | ```d.get(key, default)```        | ```key```의 value를 반환, 없을 경우 ```default(설정 x : None)``` 반환 |      |
  | ```d.setdefault(key, default)``` | ```key```가 dict에 있으면 ```value``` 반환, 없으면 ```default```를 해당 ```key```의 ```value```로 삽입 후 ```default``` 반환 / ```default```없으면 ```None``` 반환 |      |
  |                                  |                                                              |      |
  
  ```python
  # get()
  d = {1:100, 2:200}
  print(d.get(3, "반환만함"), d)
  print(d.get(3), d)
  >>> 반환만함  {1: 100, 2: 200}
      None    {1: 100, 2: 200}
  
  # setdefault()
  d = {1:100, 2:200}
  print(d.setdefault(3, "삽입후반환"), d)
  d = {1:100, 2:200}
  print(d.setdefault(3), d)
  >>> 삽입후반환 {1: 100, 2: 200, 3: '삽입후반환'}
      None     {1: 100, 2: 200, 3: None}
  
  
  ```



+ 추가 및 삭제

  | 명령어                    | 설명                                                         | 예시                              |
  | ------------------------- | ------------------------------------------------------------ | --------------------------------- |
  | ```d.pop(key, default)``` | ```key```가 dict에 있으면 제거하고, ```value``` 반환 / 없다면 default 반환 / default 없으면 KeyError |                                   |
  | ```d.update()```          | ```keyword```를 ```key```로 하고, 그 인자를 ```value```로 dict에 덮어씌움<br />```key```가 존재하지 않으면, 추가함 | ```d.updata(banana = '바나나')``` |
  |                           |                                                              |                                   |

  ```python
  # pop()
  d = {1:100, 2:200}
  print(d.pop(3, "반환만함 / 안적으면 KeyError"),d)
  >>> 반환만함 / 안적으면 KeyError {1: 100, 2: 200}
  ```

  



## 3. 얕은 복사와 깊은 복사 (매우매우 중요)

+ 기본적으로 immutable 자료들은 괜찮은데, mutable 자료들은 ```=```  or ```slicing```이용시 얕은 복사가 됨

### [1] 데이터 
#### (1) 변경 불가능한(immutable) 데이터

는 기본적으로 데이터 자체를 참조(상수값으로 취급되어, 상수들이 따로 저장되는 공간에 저장 됨) 하기 때문에 ```=```  or ```slicing``` 사용시 깊은 복사가 됨

+ 리터럴(literal)
  + 숫자 (Number)
  + 글자 (String)
  + 불리언 (Bool)

+ ```range()```

+ ```tuple()```

+ ```frozenset()```

  

#### (2) 변경 가능한(mutable) 데이터

는 기본적으로 주소를 참조하기 때문에 ```=``` or ```slicing``` 이용시 주소를 참조하는 얕은 복사가 됨




### [2] 할당 & 얕은 복사 & 깊은 복사
#### (1) 할당 (assignment)

+ ```=```  (대입 연산자)를 이용한 복사는, 해당 객체에 대한 객체 참조를 복사 (복사를 했는데, 주소값만 복사한 것)
  + list에는 각 원소들의 주소가 저장되어 있음 / 그래서 이 주소를 복사하게 됨 / 즉 같은 것을 참조하게 됨

+ 파이썬튜터 [참조](https://pythontutor.com/iframe-embed.html#code=a%20%3D%20%5B1,%202,%203,%204%5D%0Ab%20%3D%20a%0Ab%5B0%5D%20%3D%20100%0A%0Aprint%28a%29%0Aprint%28b%29&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)
+ 

#### (2) 얕은 복사 (shallow copy)

+ ```[:]``` (슬라이싱)을 이용한 복사로, 연산된 결과를 복사함 (주소가 다름)

+ ```[:]```슬라이싱 한 내부 데이터의 경우

  +  내부 원소가 mutable한 것들은 주소를 복사하여 참조함

  ```python
  # Example 1 : 문제 없는 경우
  a = [1,2,3]
  b = a[:] # id(b) != id(a)  # 주소가 다름
  b[0] = 9
  print(a)
  print(b)
  >>> [1,2,3]
      [9,2,3]
      
  # Example 2 : 주의가 필요한 경우
  a = [1, 2, [3,4]]
  b = a[:] #id(b) != id(a)            # 주소가 다름 
  b[2][0] = 1 # id(b[2]) == id(a[2])  **하지만 내부 mutable은 주소를 복사하여 참조**
  print(a)
  print(b)
  >>> [1, 2, [1,4]]
      [1, 2, [1,4]]
  ```

  

#### (3) 깊은 복사 (deep copy)

+ ```copy.deepcopy(obejct)```를 이용하여 완전히 새로운 주소로 복사

```python
import copy
a = [1, 2, [1,2,3]]
b = copy.deepcopy(a) # id(a[2]) != id(b[2])

```

