# 서로소 집합

## [1] 정의 및 활용

### (1) 정의

+ 교집합이 없음
+ 집합에 속한 하나의 특정 멤버(대표자)를 통해 각 집합들을 구분

### (2) 활용

+ 부모-자식 관계만 주어질 때, 이게 몇 개의 트리인가 판단
  + 대표자(root)의 개수를 세면 됨
+ MST 구할 때, kruscal 알고리즘에서 사용



## [2] 표현과 연산

### (1) 표현

+ **하나의 집합을 하나의 트리로 표현**
  + 자식노드가 index / 부모 노드가 value인 트리로 표현
+ 집합의 대표자

  + 루트노드



### (2) 연산

+ Make-set(x) 
  + x를 대표로하는 {x} 집합 생성
+ Find-Set(x)  
  + x를 포함하는 집합의 대표자(root) 찾기
+ Union(x,y) 
  +   x 집합의 대표 원소(root)를, y집합의 대표 원소(root)가 가리키게 함
  + 즉, x 집합의 root를 root로 해서, 두 개의 트리를 합침



### (3) 연산 예시

| 연산                                                         | index    | 1    | 2    | 3    | 4    | 5    | 6    |
| ------------------------------------------------------------ | -------- | ---- | ---- | ---- | ---- | ---- | ---- |
| make_set(1)~(6)                                              | p =      | 1    | 2    | 3    | 4    | 5    | 6    |
| union(1,3)                                                   | p =      | 1    | 2    | 1    | 4    | 5    | 6    |
| union(2,3) <br />3의 대표원소 y 찾아가서,<br /> y의 대표원소를 2의 대표원소 x로 교체 | p =      | 2    | 2    | 1    | 4    | 5    | 6    |
| union(5,6)                                                   | p =      | 2    | 2    | 1    | 4    | 5    | 5    |
| findset(6)                                                   | 5 return |      |      |      |      |      |      |





## [3] 구현 코드

```python
# 1. Make set
N = 6
p = [x for x in range(N+1)] # 스스로가 root(대표자) 가 되도록 초기화

# 2. find set
# 특정 노드 x의 대표자(root) 노드 반환
def find_set(x):
    # 구현 1
    while p[x] != x: # 자기 자신이 부모가 아닌 경우, 부모로 이동
        x = p[x]     # 부모로 이동

    return x

def find_set2(x):
    if p[x] == x:
        return x
    else:
        return find_set2(p[x])

# 3. union(x,y)
# 두 노드를 하나의 집합으로 만들어주는 함수
# y의 대표자(root)가 x의 대표자(root)를 가리키게 함
  # 즉 x의 대표자가 그대로 root / y를 포함하는 tree는 x의 subtree
def union(x,y):
    root_of_x = find_set(x)
    root_of_y = find_set(y)
    p[root_of_y] = root_of_x  # y의 대표자(root)가, x의 대표자(root)를 가리키도록
    
# 4. 위의 표 결과 실행
union(1, 3)
print(p[1:])
union(2, 3)
print(p[1:])
union(5, 6)
print(p[1:])
print(find_set(6))
```





+ 연결된 노드들의 집합에서 대표자를 설정 후, 대표자가 같으면, 서로 연결 시 사이클 발생

+ Union(a,b) 는 a 집합의 대표원소를, b집합의 대표원소가 가리키게 함
+ 즉, 대표자를 tree의 root라고 생각하면 되고, 각 원소들은 자신의 부모만 가리킴
+ 대표자가 같으면 같은 집합





# 그래프 문제

## [1] MST (모든 노드 최소비용 연결)

### (1) PRIM 알고리즘

+ 의미
  + MST에 포함된 정점에서 연결된 간선들 중에 하나씩 **Greedy**하게 선택하면서 MST를 만들어 가는 방식

+ 과정

  + 시작 : 임의의 정점 v 선택해서 MST에 포함
    + 반복 : **MST에 포함된 모든 정점에서 최소비용 간선의 정점 u(not in MST)선택**
  + 모든 정점 선택될 때까지, 바로 위 과정 반복

+ 특성

  + 사이클 안생김

  + diijkstra 와 유사

    

### (2) Kruskal 알고리즘








## [2] 특정 노드에서 다른 노드로 가는 최소 비용 계산

