





# DFS 

경로를 찾으면 즉시 이동(stack에 push), 경로를 찾지 못하면, 현재 경로에서 이전 경로로 돌아가서(stack에서 pop) 다시 경로를 찾음.

재귀를 호출하는 것은 스택에 집어넣는 것과 똑같음.

stack으로 DFS 구현시에는 break 이용해서, 새로운 경로 발견 즉시 이동

하지만 재귀에서는, 재귀함수 실행이 해당 위치로 이동을 의미하므로, break 없이 경로 찾으면 함수호출 해주면 됨 / for문에서 경로가 없으면 재귀함수가 호출되지 않아서 재귀함수 호출안되고, 그럼 해당노드가 pop 되는 것



```python
# 공통부분
#--------------------- 공통으로 필요-----------------------------------------------
N = 10
adj = [[0]*N for _ in range(N)]
visited = [False]*N
path = []

for i in range(N-1):
    adj[i][i+1] = 1
    adj[i+1][i] = 1
adj[N-3][N-1] = adj[N-1][N-3] = 1 # N-3 번과 N-1번도 연결

#--------------------------------------------------------------------------------
# 1. stack 이용
stack = []
top = -1
top += 1 # 더 큰수로 이동
start = 0
stack.append(start)
path.append(start)
visited[start] = True
while stack:
    cur = stack[-1]
    
    for i in range(N-1,-1,-1): # 핵시구조 1
        if adj[cur][i] == 1 and visited[i] == False:
            visited[i] = True
            stack.append(i)
            path.append(i)
            break     # 핵심구조 2
    else:
        stack.pop()   # 핵심구조 3


# 2. 재귀이용
	# 함수호출이 stack에 append 하는 것이고, 함수 끝나는 것이 stack에서 pop임.
	
    # v 번 노드에서 경로 찾기
    
    # 방문하지 않은 이동할 곳이 있으면 바로 이동
    
    # 이동할 곳이 없다면 이전 위치로 되돌아가기

def dfs(v): # 이 함수 시작하면, v 번 노드로 이동한다는 의미
    visited[v] = True # v번 노드 방문 표시
    path.append(v)
    for i in range(N-1,-1,-1):
        if adj[v][i] == 1 and not visited[i]:
            dfs(i)
dfs(0) # 0번 노드에서 길찾기 시작
print(path)


```



## 코드구조

1. `for-else` 문으로 `stack.append() - stack.pop()` 진행

2. `for` 에 `break` 와 `for-else` 안쓰고 하려면,  맨 위에 현재 노드 찾을 때, `stack.pop()` 하면 됨 

   ```python
   위의 예에서
   while stack:
       cur = stack.pop()
       path.append(cur)  # 추가된 부분
       # 갈 수 있는 곳 모두 stack에 넣기
       for i in range(N-1,-1,-1):
           if adj[cur][i] == 1 and visited[i] == False:
               visited[i] = True
               stack.append(i)
               #path.append(i)
               #break
       #else:
           #stack.pop()
   
   ```

   

# 후위표기와 계산기











# 백트래킹

## 활용

+ 최적화 문제

+ 결정문제

+ 예
  + 미로찾기, n-Qeen, map coloring, 부분집합, 순열
  
+ 순열

  + 각 요소가 사용되었는지 안되었는지를 알려줄 `used = [0]*N` 필요

    




## 절차

1. 상태 공간 트리의 깊이 우선 검색 실시
1.  각 노드가 유망한지 점검
1. 만일 2의 노드가 유망하지 않으면, 해당 노드의 부모 노드로 돌아가서 검색 계속

+ 해답의 가능성이 있는 경우를 **유망**하다고 함





## DFS 와 백트래킹 차이

+ DFS 는 모든 경우 다 해보고, 끝까지가서 되는지 안되는지 파악
  + 모든 경우의 수 고려

+ 백트래킹은 끝까지 가기 전 경로에서도 되는지 안되는지 파악 (가지치기)
  + 불필요한 경로 조기 차단
+ DFS 와 백트래킹은 코드 구조 같음
  + 백트래킹은 안되는 경우 미리 차단하는 조건 추가된 것









# 부분집합 / 순열

## 1. 부분집합

### [1] 비트 표현



### [2] 부분집합 표현



### [3] 부분집합 합



### [4] 부분집합 합  + 조건 1



### [5] 부분집합 합 + 조건 1, 2





## 2. 순열

