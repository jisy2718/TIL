





# DFS 

경로를 찾으면 즉시 이동(stack에 push), 경로를 찾지 못하면, 현재 경로에서 이전 경로로 돌아가서(stack에서 pop) 다시 경로를 찾음.

재귀를 호출하는 것은 스택에 집어넣는 것과 똑같음.

stack으로 DFS 구현시에는 break 이용해서, 새로운 경로 발견 즉시 이동

하지만 재귀에서는, 재귀함수 실행이 해당 위치로 이동을 의미하므로, break 없이 경로 찾으면 함수호출 해주면 됨 / for문에서 경로가 없으면 재귀함수가 호출되지 않아서 재귀함수 호출안되고, 그럼 해당노드가 pop 되는 것



```python
# 공통부분
#--------------------- 공통으로 필요-----------------------------------------------
N = 10
adj = [[0]*N for _ in range(N)]
visited = [False]*N
path = []

for i in range(N-1):
    adj[i][i+1] = 1
    adj[i+1][i] = 1
adj[N-3][N-1] = adj[N-1][N-3] = 1 # N-3 번과 N-1번도 연결

#--------------------------------------------------------------------------------
# 1. stack 이용
stack = []
top = -1
top += 1 # 더 큰수로 이동
start = 0
stack.append(start)
path.append(start)
visited[start] = True
while stack:
    cur = stack[-1]
    
    for i in range(N-1,-1,-1): # 핵시구조 1
        if adj[cur][i] == 1 and visited[i] == False:
            visited[i] = True
            stack.append(i)
            path.append(i)
            break     # 핵심구조 2
    else:
        stack.pop()   # 핵심구조 3


# 2. 재귀이용
	# 함수호출이 stack에 append 하는 것이고, 함수 끝나는 것이 stack에서 pop임.
	
    # v 번 노드에서 경로 찾기
    
    # 방문하지 않은 이동할 곳이 있으면 바로 이동
    
    # 이동할 곳이 없다면 이전 위치로 되돌아가기

def dfs(v): # 이 함수 시작하면, v 번 노드로 이동한다는 의미
    visited[v] = True # v번 노드 방문 표시
    path.append(v)
    for i in range(N-1,-1,-1):
        if adj[v][i] == 1 and not visited[i]:
            dfs(i)
dfs(0) # 0번 노드에서 길찾기 시작
print(path)


```



## 코드구조

1. `for-else` 문으로 `stack.append() - stack.pop()` 진행

2. `for` 에 `break` 와 `for-else` 안쓰고 하려면,  맨 위에 현재 노드 찾을 때, `stack.pop()` 하면 됨 

   ```python
   위의 예에서
   while stack:
       cur = stack.pop()
       path.append(cur)  # 추가된 부분
       # 갈 수 있는 곳 모두 stack에 넣기
       for i in range(N-1,-1,-1):
           if adj[cur][i] == 1 and visited[i] == False:
               visited[i] = True
               stack.append(i)
               #path.append(i)
               #break
       #else:
           #stack.pop()
   
   ```

   

# 후위표기와 계산기











# 백트래킹

## 활용

+ 최적화 문제

+ 결정문제

+ 예
  + 미로찾기, n-Qeen, map coloring, 부분집합, 순열
  
+ 순열

  + 각 요소가 사용되었는지 안되었는지를 알려줄 `used = [0]*N` 필요

    




## 절차

1. 상태 공간 트리의 깊이 우선 검색 실시
1.  각 노드가 유망한지 점검
1. 만일 2의 노드가 유망하지 않으면, 해당 노드의 부모 노드로 돌아가서 검색 계속

+ 해답의 가능성이 있는 경우를 **유망**하다고 함





## DFS 와 백트래킹 차이

+ DFS 는 모든 경우 다 해보고, 끝까지가서 되는지 안되는지 파악
  + 모든 경우의 수 고려

+ 백트래킹은 끝까지 가기 전 경로에서도 되는지 안되는지 파악 (가지치기)
  + 불필요한 경로 조기 차단
+ DFS 와 백트래킹은 코드 구조 같음
  + 백트래킹은 안되는 경우 미리 차단하는 조건 추가된 것









# 부분집합 / 순열

## 1. 부분집합

### [1] 비트 표현



### [2] 부분집합 표현



### [3] 부분집합 합



### [4] 부분집합 합  + 조건 1



### [5] 부분집합 합 + 조건 1, 2





## 2. 순열







# 트리

## 1. 기본트리

### [1] 성질

+ 간선의 수 = 정점의 수 - 1





## 2. 이진트리

### [1] 종류

#### (1) 포화이진트리 / 완전이진트리

+ 부모 node의 숫자 < 자식 node의 숫자
+ 1 번이 root

#### (2) 그외

+ 포화이진트리의 2가지 성립 x

### [2] 성질

+ 부모 index = 자식 index //2
+ 좌측 자식 index = 부모 index * 2 
+ 우측 자식 index = 부모 index*2 +1



### [3] 순회방법

#### (1)

#### (3) 후위순회

```python
# 이진트리의 경우

# 1.특정 노드 아래의 노드 개수 세기
## [1] global 변수 없이하는 법  
### 부모 노드를 index로 하고, child node는 2개의 리스트에 저장되어있음
def order(v):
    if v == 0:  # 노드가 아니면 0 반환
        return 0
    return order(ch1[n]) + order(ch2[n]) + 1  # 자식이 없으면 1 반환
```





### [4] 표현(저장)

+ 배열 저장의 단점

  + 편향 이진 트리의 경우, 사용하지 않는 배열의 원소에 대한 메모리 낭비

  + 트리의 중간에 새로운 노드를 삽입하거나, 기존의 노드를 삭제할 경우, 배열의 크기 변경 어려워 비효율적

    

#### (1) 배열 (성질 이용)

+ 정점의 최대 번호를 모두 포함할 수 있는 index를 가지는 1차원 배열을 생성

+ 완전이진트리에서 이용

  ```python
  # Index는 이진트리에서 위치 번호(1부터 시작)
  tree = [0,'A','B',0,'D',0,0,0,0,0,0,0,0,0,0,0] # 좌편향트리
  ```



+ 장점

  + 완전이진트리의 경우, 부모와 자식간의 관계를 알고 있으므로, tree에 각 노드가 담고있는 value들을 그냥 쉽게 넣을 수 있다. (아래 참고)

    ```python
    # 완전 이진 트리의 in_order
    def in_order(v):
        if v <= N: # 최대 노드 개수 N으로 주어짐
            in_order(v*2) #좌측자식
            print(tree[v],end='')
            in_order(v*2 + 1) # 우측자식
    ```

    

+ 구현

  ```python
  # 0. 트리 저장방법
  tree = [0]*(노드개수+1) # root 가 1부터 시작
  # 그 후 tree[node_idx] = node_value 로 저장해준다.
  ```

  



#### (2) 부모 노드 숫자를 index로 하는 배열 2개에 저장

+ 포화이진트리가 아닌 경우, 저장 공간을 아낄 수 있음

+ 부모 자식간에 임의 규칙으로 연결되었는 경우 이용

  | node index          | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
  | ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | child1 ( arr[0] )   | 0    | 2    | 4    | 6    | 8    | 0    | 0    | 0    | 0    |
  | child2 ( arr[1] )   | 0    | 3    | 5    | 7    | 0    | 0    | 0    | 0    | 0    |
  | node value (필요시) | 0    | 값1  | 값2  | 값3  | 값4  | 값5  | 값6  | 값7  | 값8  |
  
  이는 1 번이 root이고, 2,3을 자식으로가지고....반복하는 트리임
  
  ```python
  # 0. 트리 저장방법
  V = int(input()) # 정점 개수와 정점의 키값 일치하는 경우
  arr = [[0]* (V+1) for _ in range(2)]
  E = list(map(int,input().split()))
  
  for i in range(0, len(E),2):
      parent, child = E[i], E[i+1]
      # print(parent, child)
      if arr[0][parent]:
          arr[1][parent] = child
      else:
          arr[0][parent] = child
          
  ```
  
  



#### (3) 자식 노드 숫자를 index로 하는 배열에 , 부모 노드 index 저장

+ 루트 찾기, 조상찾기에 활용 가능
  + 포화 & 완전 이진트리 아닌 경우

| node index | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| parent     | 0    | 0    | 1    | 1    | 2    | 2    | 3    | 3    | 4    |

```python
# 0. 트리 저장방법
parent = [0]*(V+1)
for e in range(E):
    read p, c
    parent[c] = p
	

# 1. 루트찾는 코드
root = 0 
for i in range(1,V+1):
    if parent[i] == 0:
        root = i
        break
print(root)

# 2. 조상찾는 코드
# 5의 조상을 찾아봐라
c = 5
anc = []
while parent[c] != 0 :
    anc.append(parent[c])
    c = parent[c]
print(anc)
```







#### (4) 2차원 배열 비대칭

+ 2차원 배열에서 각 행을 모든 노드로 볼 때, 열에 좌, 우 자식 노드를 1, 2 와 같이 표기
  + 이렇게 하면, 자식 노드가 k 개 있어도 표현 가능







## 3. 그 외 이진트리

### [1] 수식트리





### [2] 이진탐색트리

#### (1) 정의

+ 모든 노드는 유일한 값 가짐
+ 부모 노드의 왼쪽에 있는 노드들의 값은 부모보다 작음
+ 부모 노드의 오른쪽에 있는 노드들의 값은 부모보다 큼



#### (2) 탐색

+ 부등호로 비교해가며 자식들 중 한 쪽 자식의 트리만 탐색하면 됨 







### [3] 힙

+ 정의

  + 완전 이진트리이고,

  + 부모와 자식 간의 대소 관계가 항상 한쪽이 더 크거나, 더 작음

    

+ 활용

  + 우선순위 큐 구현

  + 값 저장하고, 최소값, 최대값 가져오기 위한 자료구조

    + root 의 값을 계속 가져온다고 생각하면 됨(root delete 이용해 힙정렬)

      

+ 구현

  + 마지막 요소 위치 알려주는 변수 필요

  

  

#### (1) 최대힙

+ 정의

  + 키값이 가장 큰 노드를 찾는 완전이진트리


  + 부모 키값 > 자식 키값


  + 루트 : 가장 큰 키값 노드

    


#### (2) 최소힙

+ 정의

  + 키값이 가장 작은 노드를 찾는 완전이진트리


  + 부모 키값 < 자식 키값


  + 루트 : 가장 작은 키값 노드




#### (3) 삽입연산

+ 가장 마지막 노드자리에 삽입 후, 부모와 자식 간에 대소비교하여, 위치 잘 찾아주기



#### (4) 삭제연산

+ 항상 root의 요소를 반환하고, root 없애고, heap 다시 정렬하면 됨
+ 새로 root가 되는 요소
  + 제일 마지막 요소 (나머지는 heap인 상태로 유지됨 + 완전이진트리 유지)
+ 교환 순서
  + 최대힙 : root의 좌, 우 노드 중, 큰 것과 비교
  + 최소힙 : root의 좌, 우 노드 중, 작은 것과 비교









공통조상찾기

